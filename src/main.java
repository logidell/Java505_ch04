public class main {
    public static void main(String[] args) {
        //클래스 타입 변수
//        객체 = 사물 = 부품/ 이름이 있는 명사
//        이 고유 툭성(state)과 행동(behavior 클릭등등)을 가짐.
//        객체지향프로그래밍 : 부품객체를 먼저 만든 뒤 이 부품들을 조립해 완성된 프로그램을 만드는 기법
//        객체간의 관계 : 객체들은 다른 객체들과 관계를 맺는다.
//        집합관계 / 사용관계 / 상속관계
//        집합관계: 완성품과 부품의 관계
//        사용관계 : 하나의 객체가 다른 객체 이용하는 관계
//        상속관계 : 종류 객체와 구체적 사물 객체 관계

//        객체지향프로그래밍의 특징
//        캡슐화 : 사용방법만 알려주고 내부 구성은 숨기는 방식
//          운전으로 치자면 운전 방법만 알려주고 자동차의 구성,차의 유지보수, 차의 동작방법은 알려주지 않음.
//          외부 객체는 객체 내부 구조를 알지 못하고 객체가 노출해 제공하는 필드, 메소드만 이용 가능
//          필드와 메소드 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체 손상치 않도록
//            - 잘못된 사용으로 망가트리지 않게
//        상속 : 상위 부모 객체의 필드(특성)와 메소드(행동)를 하위자식객체에게 물려주는 행위
//              하위 객체는 상위 객체를 확장해 추가적 필드 메소드 가질 수 있다.
//                -상속의 효과
//                    상위 객체 재사용해 개발이 빨라짐 -> 유지보수가 좋아진다.
//                    반복 코드의 중복을 줄인다
//                    객체 다양성 구현
//        다형성 : 같은 타입이나 실행결과가 다양한 객체를 대입할 수 있는 성질 (차로 치자면 타이어? 키보드? 같은 키보드지만
//                  회사마다 다른 키보드를 내는 것?)

//      class 클래스 = 설명서 = 레시피 = 설계도
//        클래스에는 객체를 생성하기 위한 필드와 메소드가 정의. 클래스부터 만들어진 객체를 해당 클래스에 인스턴스
//        하나의 클래스로부터 여러개의 인스턴스를 만들 수 있다. -> 설계도 자체로는 프로그래밍을 할 수 없으나 참고가 가능
//        이 설계도로 뭘 만든 것을 객체. 도면에서부터 무언가를 만드는 것을 객체화 또는 인스턴스화 라고 한다.
//      class 선언
//        클래스의 이름은 자바 식별자 작성 규칙을 따른다.
//    class 선언과 컴파일
//        public class  이름  / 소스파일당 하나의 클래스 선언하는 것이 관례


//  new 연산자
//        객체 생성 역할
//        new 클래스(); : 객체 생성
//        클래스() 는 생성자를 호출하는 코드. 생성된 객체는 힙 메모리 영역에 생성된다.
//        new 연산자는 객체 생성 후 객체 생성 메모리 주소 리턴
//     클래스 타입 변수  = new 클래스();
//       new 연산자에 의해 리턴된 객체의 주소 저장
//     클래스의 용도
//        라이브러리용:자체적으로 실행되지 않으나 다른 클래스에서 이용할 목적으로 만든 클래스
//        실행용 : main() 메소드를 가지고 있는 클래스로 실행할 목적으로 만든 클래스
//    클래스 내부구조
//        필드 / 생성자 / 메소드
//        필드 : 변수 (클래스 멤버 변수)
//        메소드(클래스에 포함되어있는 아이) : 로직으로 된 것이 한 곳에 모아진 것 = 함수 (혼자 동작가능한 아이)
//        생성자 : 객체가 실행될 때 생성되는 메서드  / 파괴자?


//        필드  타입필드 [=초기값];
//        객체의 고유 데이터 / 객체가 가져야 할 부품 객체 / 객체의 현재 상태 데이터
//        필드 선언 : 변수 선언과 같음.
//        기본 초기값 char , 논리타입 제외 전부 0 (char 빈 공백  / 논리타입 : false)
//        참조타입은 전부 null값
//        필드 사용
//            객체 내부 " "필드이름" 처럼 기본 방법 그대로 사용.
//            객체 외부  "변수.필드이름"


        Circle pizza;
//        circele  클래스 타입으 ㅣ변수, 클래스 ㅇ의 객체 주소 저장

        pizza = new Circle();

//        CIRCLE 클래스는 설계도이기에 혼자 존재하는 어떠한 행동도 할 수 없음
//        객체의 생성함으로서 cirlce 클래스 실체 생성
//        객체가 생성되면 해당 클래스에 포함된 멤버들을 사용할 수 있다.
        pizza.radius = 10;
        pizza.name = "자바피자";
        double area = pizza.getArea();
        System.out.println(pizza.name + "의 면적은 " + area);

        Circle donut = new Circle();
        donut.radius = 2;
        donut.name = "자바도넛";
        area = donut.getArea();
        System.out.println(donut.name + "의 면적은 " + area);


//-------------------------------------

        Car car2 = new Car("토레스", "SUV", "가솔린", "준중형");
        System.out.println(car2.name);
        System.out.println(car2.type);

//        ============================================================================================================


    }


}
